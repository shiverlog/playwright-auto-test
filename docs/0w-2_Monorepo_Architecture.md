###### - 민시우(2025/03/10) 작성 -

## 0w-2. 🏗️ 모노레포 구조를 도입하여야 하는 이유

### [1] 📦 아키텍쳐 비교

<p align="center">
  <img src="https://miro.medium.com/v2/resize:fit:691/0*joulAAdTFGe-chHP.png"/>
</p>

#### `모놀리식 아키텍처 (Monolithic Architecture)`

- 테스트 자동화 프로젝트에서 모든 테스트(UI, API, 성능 테스트 등)가 하나의 코드베이스 내에서 통합되어 실행되는 구조를 의미한다.
- 모든 프로세스가 긴밀하게 결합되어 있어 테스트 환경 설정, 실행, 배포가 단순하다.
- 프로젝트가 커질수록 유지보수 및 확장성이 어려워진다.
- 병렬 실행 및 독립적인 테스트 수행이 어렵고, 특정 기능 변경 시 전체 프로젝트에 영향을 줄 가능성이 높다.

#### `멀티 모듈 아키텍쳐(Multi-Module Architecture)`

- 테스트 자동화 프로젝트에서 UI 테스트, API 테스트, 성능 테스트 등을 각각 독립적인 모듈로 분리하여 관리하는 구조이다.
- 확장성과 유지보수성을 극대화할 수 있으며, 모듈 간 의존성을 분리하여 독립적인 개발 및 테스트 수행 가능하다.
- Docker 및 CI/CD와 결합하여 모듈별 빌드 및 배포 가능하며,
  특정 모듈만 실행할 수 있어 테스트 속도 최적화 및 병렬 실행 가능하다.
- 모듈 간 버전 관리가 복잡해질 가능성이 있으며, 여러 개의 저장소로 운영하면 공통 코드 및 라이브러리 공유가 복잡해질 수 있다.

#### `모노레포 아키텍쳐(Monorepo Architecture)`

- 여러 개의 관련된 프로젝트를 하나의 저장소(repository)에서 관리하는 방식이다.
- 모든 모듈이 단일 저장소에서 유지되며, 각 모듈이 독립적으로 빌드 및 테스트 가능하다.
- 공통 라이브러리 및 설정을 공유하여 코드 일관성 유지하며, 모듈 간 의존성 및 버전 관리를 중앙에서 통제 가능하다.
- Docker 및 CI/CD와 결합하여 최적의 테스트 실행 환경을 구축할 수 있으며, 변경된 코드만 테스트하고 배포하는 Selective Test & Deployment 가능하다.
- 개별 모듈 단위로 빌드 및 배포 가능하여 테스트 속도 및 배포 안정성이 증가한다.
- 여러 개의 관련된 프로젝트를 하나의 저장소(repository)에서 관리하는 방식으로, 모든 모듈이 단일 저장소에서 유지되며, 개별 모듈이 독립적으로 빌드 및 테스트 가능하며, 공통 라이브러리 및 설정을 공유하여 일관성을 유지하며, 코드 변경 사항을 중앙에서 추적 가능하며, Docker 및 CI/CD와 결합하여 최적의 테스트 실행 환경을 구축할 수 있다.
- 하나의 저장소에서 모든 프로젝트를 관리해야 하므로 Git 히스토리가 커질 가능성이 있으며, 대규모 프로젝트에서는 빌드 및 배포 시 모듈 간 의존성 관리를 신중하게 설계해야 한다.

---

`각각의 아키텍쳐 비교`

| 비교 항목                  | 모놀리식                                                           | 멀티 모듈                                                                                            | 모노레포                                                                                            |
| -------------------------- | ------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| **구성**                   | 모든 테스트(UI, API, 성능 테스트 등)가 하나의 프로젝트 내에서 실행 | 테스트 유형별로 UI, API, 성능 테스트 등을 개별 모듈로 분리                                           | 여러 개의 관련된 프로젝트를 하나의 저장소에서 관리하며, 모듈별로 독립적인 빌드 및 테스트 가능       |
| **확장성**                 | 프로젝트가 커질수록 유지보수 및 확장 어려움                        | 새로운 기능 및 테스트 유형 추가가 용이                                                               | 새로운 모듈을 추가하더라도 전체 코드베이스의 일관성을 유지하면서 확장 가능                          |
| **유지보수성**             | 특정 기능 변경 시 전체 프로젝트에 영향                             | 각 모듈이 독립적으로 존재하여 유지보수 용이                                                          | 공통 라이브러리 및 설정을 공유하여 유지보수가 용이, 코드 변경 사항을 중앙에서 추적 가능             |
| **테스트 실행**            | 모든 테스트가 한 번에 실행됨 → 실행 시간이 길어짐                  | 필요한 모듈만 실행하여 테스트 속도 최적화 가능                                                       | 변경된 모듈만 선택적으로 테스트 실행 가능 → 실행 시간 단축 가능                                     |
| **빌드 및 배포**           | 모든 테스트가 한 프로젝트에서 빌드되어 시간이 오래 걸림            | 모듈별로 독립적인 빌드 및 배포 가능                                                                  | 각 모듈별 독립적인 빌드 및 배포 가능, 변경된 모듈만 선택적으로 빌드 가능                            |
| **오류 감지 및 영향 범위** | 한 테스트에서 오류 발생 시 전체 테스트 실행에 영향                 | 개별 모듈 내에서 오류가 발생해도 다른 모듈에 영향 없음                                               | 중앙에서 코드 변경 사항을 추적하고, 특정 모듈에서 발생한 오류만 해당 모듈에 국한됨                  |
| **CI/CD 연동**             | 전체 테스트를 한 번에 실행해야 하므로 속도가 느림                  | 특정 모듈만 실행 가능하여 최적화 가능                                                                | 변경된 모듈만 빌드하고 테스트 실행 가능하여 CI/CD 성능 최적화 가능                                  |
| **병렬 실행 가능 여부**    | 모든 테스트를 한 번에 실행해야 하므로 병렬 실행 어려움             | 테스트 모듈을 분리하여 병렬 실행 가능                                                                | 개별 모듈을 병렬로 빌드 및 테스트 가능, 실행 속도 최적화 가능                                       |
| **기술 스택 다양성**       | 하나의 프레임워크와 언어만 사용 가능 (예: Playwright + TypeScript) | 각 모듈별로 적절한 기술 선택 가능 (UI 테스트: Playwright, API 테스트: Supertest, 성능 테스트: k6 등) | 다양한 기술 스택을 하나의 저장소에서 관리 가능 (각 모듈별로 서로 다른 프레임워크 및 언어 적용 가능) |
| **Docker 활용**            | 하나의 컨테이너에서 모든 테스트 실행                               | 모듈별 개별 컨테이너 실행 가능                                                                       | 각 모듈별로 Docker 컨테이너를 실행 가능하며, CI/CD에서 컨테이너 기반 테스트 및 배포 최적화 가능     |

**결론**: 모놀리식은 유지보수가 어려운 반면, 단순한 프로젝트에서는 적용하기 쉽고,
멀티모듈은 독립적인 개발과 배포가 가능하지만, 관리가 복잡해질 수 있다. 모노레포는 코드 일관성과 협업 효율성을 높이면서, Docker 및 CI/CD와 결합하여 최적화된 테스트 환경을 구축할 수 있어 모노레포 아키텍쳐 형식의 프로젝트 설계가 필요할 것으로 사료된다.

---

#### `Page Object Model (POM) 구조`

모놀리식 POM 구조 예시

- 단일 프로젝트 구조
  ```plaintext
  monolithic-test/
  ├── base/                       # WebDriver 기본 설정 및 공통 클래스
  ├── config/                     # 프로젝트 설정 파일
  ├── features/                   # 테스트 기능 구현
  ├── locators/                   # 웹 요소 위치 정보
  ├── logs/                       # 로그 파일 저장
  ├── pages/                      # 페이지 객체 모델
  ├── screenshots/                # 테스트 중 캡처된 스크린샷
  ├── utils/                      # 유틸리티 함수 모음
  ├── README.md                   # 프로젝트 설명 문서
  ├── requirements.txt            # 프로젝트 의존성 목록
  └── runner.py                   # 테스트 실행 스크립트
  ```

멀티 모듈 POM 구조 예시

- 각 기능을 독립적인 모듈로 분리하며, 공통 모듈(Common)을 별도로 두고 API 테스트, UI 테스트, DB 등을 개별 프로젝트로 관리

  ```
  multi-module-test/
  │── common/ # 공통 모듈 (유틸리티, 설정, 공통 라이브러리)
  │ ├── src/
  │ │ ├── utils/ # 공통 유틸리티 함수 모음
  │ ├── package.json
  │ ├── tsconfig.json
  │ ├── Dockerfile # 공통 모듈을 도커 이미지로 만들 수 있도록 설정
  │ └── README.md
  │
  │── api-tests/ # API 테스트 프로젝트
  │ ├── src/
  │ │ ├── tests/ # API 테스트 코드
  │ ├── swagger/ # Swagger API 문서 및 설정
  │ ├── postman/ # Postman 컬렉션 및 테스트
  │ ├── package.json
  │ ├── playwright.config.ts
  │ ├── Dockerfile # API 테스트를 컨테이너화
  │ └── README.md
  │
  │── ui-tests/ # UI 테스트 프로젝트 (Playwright)
  │ ├── src/
  │ │ ├── tests/ # Playwright 테스트 코드
  │ ├── pages/ # Page Object Model 구조
  │ ├── playwright.config.ts # Playwright 설정 파일
  │ ├── package.json
  │ ├── Dockerfile # UI 테스트 컨테이너 설정
  │ └── README.md
  │
  │── db/ # DB 관리 프로젝트
  │ ├── migrations/ # DB 마이그레이션 스크립트
  │ ├── seeds/ # 테스트 데이터 시드
  │ ├── package.json
  │ ├── Dockerfile # DB 컨테이너 생성 (MySQL, PostgreSQL 등)
  │ └── README.md
  │
  │── batch/ # 배치 실행 프로젝트
  │ ├── scripts/ # 배치 파일 (Shell, PowerShell, Windows)
  │ ├── package.json
  │ ├── Dockerfile # 배치 실행을 위한 컨테이너 구성
  │ └── README.md
  │
  │── package.json # 루트 패키지 관리 (각 모듈 공통 종속성 관리)
  └── README.md # 프로젝트 설명 문서

  ```

모노레포 POM 구조 예시

- 하나의 저장소에서 모든 모듈을 관리하는 방식

  ```plaintext
  monorepo-test/
  │── .github/                    # GitHub Actions 및 CI/CD 설정
  │── .husky/                     # Git pre-commit/pre-push hooks 설정
  │── .vscode/                    # VSCode 프로젝트 설정
  │
  │── batch/                      # 배치 실행 프로젝트
  │   ├── scripts/                # 배치 실행 스크립트
  │   ├── Dockerfile              # 배치 실행을 위한 컨테이너 구성
  │   └── package.json
  │
  │── common/                     # 공통 모듈 (유틸리티, 설정, 공통 라이브러리)
  │   ├── src/
  │   │   ├── utils/              # 공통 유틸리티 함수 모음
  │   ├── package.json
  │   ├── tsconfig.json
  │   └── Dockerfile              # 공통 모듈을 도커 이미지로 만들 수 있도록 설정
  │
  │── docs/                       # 프로젝트 문서 및 API 명세서
  │
  │── e2e/                        # E2E 테스트 모듈 (Playwright 기반)
  │   ├── android/                # Android 앱 테스트
  │   ├── api/                    # API 테스트
  │   ├── ios/                    # iOS 앱 테스트
  │   ├── mobile-web/             # 모바일 웹 테스트
  │   └── pc-web/                 # PC 웹 테스트
  │
  │── mosaic-db/                  # DB 관리 모듈
  │   ├── migrations/             # DB 마이그레이션 스크립트
  │   ├── seeds/                  # 테스트 데이터 시드
  │   ├── package.json
  │   └── Dockerfile              # DB 컨테이너 생성 (MySQL, PostgreSQL 등)
  │
  │── pubsub/                     # Pub/Sub 메시징 시스템
  │   ├── src/
  │   │   ├── publisher.ts
  │   │   └── subscriber.ts
  │   └── Dockerfile              # PubSub 메시징 컨테이너화
  │
  │── speedtest/                  # 성능 테스트 모듈
  │   ├── src/
  │   │   └── performance.ts
  │   ├── package.json
  │   └── Dockerfile              # 성능 테스트 컨테이너 설정
  │
  │── test-results/               # 테스트 실행 결과 저장소
  │── tests/                      # 단위 테스트 및 기능 테스트
  │── tests-examples/             # 테스트 예제 코드
  │
  │── node_modules/               # 프로젝트 의존성
  │── playwright-report/          # Playwright 테스트 리포트
  │── package.json                # 프로젝트 전체 의존성 관리
  │── package-lock.json           # 종속성 잠금 파일
  │── docker-compose.yml          # Docker 컨테이너 설정
  │── dependencies.json           # 프로젝트 의존성 정보
  │── .gitignore                  # Git 제외 파일 설정
  │── .eslintignore               # ESLint 제외 파일 설정
  │── .eslintrc.json              # ESLint 설정 파일
  └── .prettierrc.json            # Prettier 코드 스타일 설정
  ```

  **결론**:

  - 프로젝트의 확장성과 유지보수성을 고려했을 때, 모듈화된 구조를 기반으로 한 모노레포 아키텍처를 적용하는 것이 가장 효과적이며, 각 기능을 개별적인 모듈로 분리함으로써 독립적인 실행이 가능해지고, CI/CD 환경에서도 변경된 모듈만 선택적으로 테스트 및 배포할 수 있어 실행 속도를 최적화할 수 있다.
  - 특히, 기존의 테스트 케이스(Test Case) 단위로 모든 검증을 하나의 함수에서 처리하는 방식은 유지보수성이 떨어지고 실행 시간이 길어지는 문제를 초래한다. 따라서, 기능별로 테스트를 분리하고, 컴포넌트/메서드 기반의 구조를 도입함으로써 코드의 일관성을 유지하면서도 테스트 효율성을 높여야 한다. 또한, Docker 기반의 컨테이너화된 환경을 활용하면, 테스트 환경을 표준화하고 개별 테스트 모듈이 독립적으로 실행될 수 있어, 팀 내 협업이 원활해지고 CI/CD 환경에서도 최적의 테스트 자동화 시스템을 구축할 수 있다.

---

### [2] 🔍 참고 자료

- [모놀리식 vs 마이크로서비스 아키텍처 개념](https://martinfowler.com/articles/microservices.html)
- [멀티 모듈 아키텍처 개념](https://docs.gradle.org/current/userguide/multi_project_builds.html)
- [Docker 공식 문서](https://docs.docker.com/)
- [Kubernetes 공식 사이트](https://kubernetes.io/)
- [CI/CD 개념 및 도구 비교](https://www.redhat.com/en/topics/devops/what-is-ci-cd)

```

```
